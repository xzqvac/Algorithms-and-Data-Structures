\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage[edges]{forest}
\usepackage{listings}
\usepackage{multicol}
\usepackage[utf8]{inputenc}
\usepackage[breaklinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title {
    \Huge\textbf{Algorytmy i struktury danych} \\
    \vspace{2mm}
    \huge{Lista zadań 7 - B-drzewa} 
    \date{}
}

\begin{document}
    \maketitle
    \boldmath
    \section*{Zadanie 1}
        Zapisz warunki jakie muszą spełniać klucze drzewa BST.
        \begin{itemize}
            \item Klucze w lewym poddrzewie są mniejsze od klucza w danym węźle.
            \item Klucze w prawym poddrzewie są większe lub równe kluczowi w danym węźle.
        \end{itemize}

    \section*{Zadanie 2}
    Napisz procedurę node* find(node* tree, int x), która zwraca wskaźnik na węzeł 
    zawierający x lub NULL, jeśli nie ma takiego węzła.
    \begin{lstlisting}
    node *find(node *tree, int x) // wyszukiwanie klucza (nierekurencyjne)
    {
        while (tree->key != x)
            if (tree == nullptr) return nullptr;
            if (tree->key > x) tree = tree->left;	 
            else				 
                tree = tree->right;	 
        return tree;
    }

    node *find(node *tree, int x) // wyszukiwanie klucza (rekurencyjne)
    {   
        if (tree == nullptr) return nullptr;
        if (tree->key == x) return tree;		   
        if (tree->key > x) return find_recursive(tree->left, x);										
        return find(tree->right, x); 
    }
    \end{lstlisting}

    \section*{Zadanie 3}
    Napisz procedurę void insert(node *tree, int x) (dodaje do drzewa tree klucz x).
    \begin{lstlisting}
    void insert(node *&tree, int x) // wstawianie (rekurencyjnie)
    {
        if (tree == nullptr)	 
            tree = new node(x); 

        else if (tree->key > x)			   
            insert(tree->left, x);  
        else							   
            insert(tree->right, x); 
    }
    \end{lstlisting}

    \section*{Zadanie 4}

    \begin{itemize}
        \item Narysuj drzewo BST reprezentowane przez listę par: 1:2, 2:4, 3:2, 4:5, 6:7, 7:9, 8:7, 9:5.
        \item Wypisz jego klucze w porządku: INORDER, PREORDER, POSTORDER.
    \end{itemize}

    \begin{lstlisting}
    void inOrder(node *tree)
    {
        if (tree != nullptr)
        {
            inOrder(tree->left);	 // wypisze klucze z lewego poddrzewa
            std::cout << tree->key;  // wypisz klucz z wezla
            inOrder(tree->right);	 // wypisze klucze z lewego poddrzewa
        }
    }
    \end{lstlisting}

    \begin{lstlisting}
    void preOrder(node *tree)
    {
        if (tree != nullptr)
        {
            std::cout << tree->key;  // najpierw wypisz klucz z wezla
            preOrder(tree->left);	 // a potem klucze z lewego
            preOrder(tree->right);	 // i prawego poddrzewa
        }
    }
    \end{lstlisting}

    \begin{lstlisting}
    void postOrder(node *tree)
    {
        if (tree != nullptr)
        {
            postOrder(tree->left);	 // wypisz klucze z poddrzewa lewego,
            postOrder(tree->right);	 // potem z prawego,
            std::cout << tree->key;  // a na koncu klucz z wezla
        }
    }
    \end{lstlisting}
\end{document}