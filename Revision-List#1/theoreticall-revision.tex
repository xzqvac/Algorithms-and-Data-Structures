\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage[edges]{forest}
\usepackage{listings}
\usepackage{multicol}
\usepackage[utf8]{inputenc}
\usepackage[breaklinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title {
    \Huge\textbf{Algorytmy i struktury danych} \\
    \vspace{2mm}
    \huge{Sortowanie i kopce} 
    \date{}
}

\begin{document}
    \maketitle
    \boldmath
    \section*{Przygotowanie do kolokwium}
    Przyjmując, że \verb+tabA[] = {1, 2, 3, 4, 5, 6, 7}+ oraz \verb+tabB[] = {7, 6, 5, 4, 3, 2, 1}+ i stosując algorytmy
    sortujące ściśle według procedur z pliku sort2023.cc wykonaj polecenia:

    \subsection*{Zadanie 1}
    Ile dokładnie porównań (między elementami tablic) wykona \verb+insertion_sort(tabB)+, a ile \verb+insertion_sort(tabA)+?

    \begin{center}
        \textbf{Przypadek optymistyczny}
        \begin{center}
            Dla tablicy posortowanej rosnąco o długości n, \verb+insertion_sort+ wykona \textbf{n-1 porównań}. \\
            \verb+insertion_sort+ dla tablicy tabA wykona \textbf{6 porównań}. \\ 
            Złożoność czasowa: $O(n)$
        \end{center}

        \textbf{Przypadek pesymistyczny}
        \begin{center}
            Dla tablicy posortowanej malejąco o długości n, \verb+insertion_sort+ wykona $\frac{n^2 - n}{2}$ \textbf{porównań}. \\ 
            \verb+insertion_sort+ dla tablicy tabA wykona \textbf{21 porównań}. \\
            Złożoność czasowa: $O(n^2)$
        \end{center}
    \end{center}

    \subsection*{Zadanie 2}
    Ile co najwyżej porównań (między elementami tablic) wykona procedura scalająca \verb+merge+ dwie tablice n-elementowe?
    \begin{center}
        Procedura scalająca dwie tablice n-elementowe \verb+merge+ wykona co najwyżej $2n - 1$ \textbf{porównań} \\ 
        w przypadku, gdy elementy tablic są posortowane naprzemiennie rosnąco. \\
        Złożoność czasowa procedury merge dla każdego przypadku: $O(n)$
        \begin{lstlisting}
        void merge(int n, int k, double leftTable[], double rightTable[]) {
        int i = 0; 
        int j = k; 
        int l = 0; 
        while (i < k && j < n) 
            if (leftTable[i] <= leftTable[j]) 
                rightTable[l++] = leftTable[i++];
            else
                rightTable[l++] = leftTable[j++];

        while (i < k)
            leftTable[--j] = leftTable[--k];

        for (i = 0; i < j; i++)
            leftTable[i] = rightTable[i];
        }
        \end{lstlisting}
    \end{center}
    
    \subsection*{Zadanie 3}
    Jaka jest pesymistyczna złożoność czasowa procedury \verb+merge_sort+? Odpowiedź uzasadnij.
    \begin{center}
        Złożoność czasowa procedury \verb+merge_sort+ wynosi $O(nlogn)$, ponieważ każde wywołanie procedury 
        \verb+merge_sort+ dzieli tablicę na dwie części o połowie długości, a następnie wywołuje procedurę \verb+merge+ 
        na tych dwóch częściach. Złożoność czasowa nie zależy od ilości elementów i tego jak są posortowane. 
        Algorym \verb+merge_sort+ składa się z dwóch etapów: divide i merge. \\
        \begin{center}
            Złożoność czasowa etapu divide wynosi $O(n)$, ponieważ wykonujemy $n - 1$ podziałów. \\
            Złożoność czasowa etapu merge wynosi $O(nlogn)$, ponieważ wykonujemy $lb n$ scaleń mając zawsze
            do dyspozycji $n$ elementów. \\                
        \end{center}
        Razem złożoność czasowa algorytmu \verb+merge_sort+ wynosi: $O(n) + O(nlogn) = O(nlogn)$
    \end{center}
    \begin{gather*}
        \text{Dowód metodą rekurencji uniwersalnej:} \\
        T(n) = 2T(n/2) + O(n) \\
        f(n) = n^{log_2 2} = n \\
        \text{Rozważamy drugi przypadek:} \\
        T(n) = O(n \log n)
    \end{gather*}

    \subsection*{Zadanie 4}
    Ile co najwyżej porównań (między elementami tablicy) wykona procedura partition?
    \begin{center}
        Procedura partition wykona co najwyżej $n + 1$ \textbf{porównań}. \\
    \end{center}

    \begin{lstlisting}
        int partition(double t[], int n) 
        {
            int k = -1;
            double x = t[n / 2];
            for (;;) {
                do
                    ++k;
                while (t[k] < x);

                do
                    --n;
                while (t[n] > x);

                if (k < n)
                    std::swap(t[k], t[n]);
                else
                    return k;
            }
        }
    \end{lstlisting}

\end{document}