\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage[edges]{forest}
\usepackage{listings}
\usepackage{multicol}
\usepackage[utf8]{inputenc}
\usepackage[breaklinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{
    \Huge\textbf{Algorytmy i struktury danych} \\
    \vspace{2mm}
    \huge{Sortowanie i kopce} 
    \date{}
}

\begin{document}
    \maketitle
    \boldmath
    \section*{Przygotowanie do kolokwium}
    Przyjmując, że \verb+tabA[] = {1, 2, 3, 4, 5, 6, 7}+ oraz \verb+tabB[] = {7, 6, 5, 4, 3, 2, 1}+ i stosując algorytmy
    sortujące ściśle według procedur z pliku sort2023.cc wykonaj polecenia:

    \subsection*{Zadanie 1}
    Ile dokładnie porównań (między elementami tablic) wykona \verb+insertion_sort(tabB)+, a ile \verb+insertion_sort(tabA)+?

    \begin{center}
        \textbf{Przypadek optymistyczny}
        \begin{center}
            Dla tablicy posortowanej rosnąco o długości n, \verb+insertion_sort+ wykona \textbf{n-1 porównań}. \\
            \verb+insertion_sort+ dla tablicy tabA wykona \textbf{6 porównań}. \\ 
            Złożoność czasowa: $O(n)$
        \end{center}

        \textbf{Przypadek pesymistyczny}
        \begin{center}
            Dla tablicy posortowanej malejąco o długości n, \verb+insertion_sort+ wykona $\frac{n^2 - n}{2}$ \textbf{porównań}. \\ 
            \verb+insertion_sort+ dla tablicy tabA wykona \textbf{21 porównań}. \\
            Złożoność czasowa: $O(n^2)$
        \end{center}
    \end{center}

    \subsection*{Zadanie 2}
    Ile co najwyżej porównań (między elementami tablic) wykona procedura scalająca \verb+merge+ dwie tablice n-elementowe?
    \begin{center}
        Procedura scalająca dwie tablice n-elementowe \verb+merge+ wykona co najwyżej $2n - 1$ \textbf{porównań} \\ 
        w przypadku, gdy elementy tablic są posortowane naprzemiennie rosnąco. \\
        Złożoność czasowa procedury merge dla każdego przypadku: $O(n)$
        \begin{lstlisting}
        void merge(int n, int k, double leftTable[], double rightTable[]) {
        int i = 0; 
        int j = k; 
        int l = 0; 
        while (i < k && j < n) 
            if (leftTable[i] <= leftTable[j]) 
                rightTable[l++] = leftTable[i++];
            else
                rightTable[l++] = leftTable[j++];

        while (i < k)
            leftTable[--j] = leftTable[--k];

        for (i = 0; i < j; i++)
            leftTable[i] = rightTable[i];
        }
        \end{lstlisting}
    \end{center}
        
\end{document}