\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage[edges]{forest}
\usepackage{listings}
\usepackage{multicol}
\usepackage[utf8]{inputenc}
\usepackage[breaklinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title {
    \Huge\textbf{Algorytmy i struktury danych} \\
    \vspace{2mm}
    \huge{Sortowanie i kopce} 
    \date{}
}

\begin{document}
    \maketitle
    \boldmath
    \section*{Przygotowanie do kolokwium}
    Przyjmując, że \verb+tabA[] = {1, 2, 3, 4, 5, 6, 7}+ oraz \verb+tabB[] = {7, 6, 5, 4, 3, 2, 1}+ i stosując algorytmy
    sortujące ściśle według procedur z pliku sort2023.cc wykonaj polecenia:

    \subsection*{Zadanie 1}
    Ile dokładnie porównań (między elementami tablic) wykona \verb+insertion_sort(tabB)+, a ile \verb+insertion_sort(tabA)+?

    \begin{center}
        \textbf{Przypadek optymistyczny}
        \begin{center}
            Dla tablicy posortowanej rosnąco o długości n, \verb+insertion_sort+ wykona \textbf{n-1 porównań}. \\
            \verb+insertion_sort+ dla tablicy tabA wykona \textbf{6 porównań}. \\ 
            Złożoność czasowa: $O(n)$
        \end{center}

        \textbf{Przypadek pesymistyczny}
        \begin{center}
            Dla tablicy posortowanej malejąco o długości n, \verb+insertion_sort+ wykona $\frac{n^2 - n}{2}$ \textbf{porównań}. \\ 
            \verb+insertion_sort+ dla tablicy tabA wykona \textbf{21 porównań}. \\
            Złożoność czasowa: $O(n^2)$
        \end{center}
    \end{center}

    \subsection*{Zadanie 2}
    Ile co najwyżej porównań (między elementami tablic) wykona procedura scalająca \verb+merge+ dwie tablice n-elementowe?
    \begin{center}
        Procedura scalająca dwie tablice n-elementowe \verb+merge+ wykona co najwyżej $2n - 1$ \textbf{porównań} \\ 
        w przypadku, gdy elementy tablic są posortowane naprzemiennie rosnąco. \\
        Złożoność czasowa procedury merge dla każdego przypadku: $O(n)$
        \begin{lstlisting}
        void merge(int n, int k, double leftTable[], double rightTable[]) {
        int i = 0; 
        int j = k; 
        int l = 0; 
        while (i < k && j < n) 
            if (leftTable[i] <= leftTable[j]) 
                rightTable[l++] = leftTable[i++];
            else
                rightTable[l++] = leftTable[j++];

        while (i < k)
            leftTable[--j] = leftTable[--k];

        for (i = 0; i < j; i++)
            leftTable[i] = rightTable[i];
        }
        \end{lstlisting}
    \end{center}
    
    \subsection*{Zadanie 3}
    Jaka jest pesymistyczna złożoność czasowa procedury \verb+merge_sort+? Odpowiedź uzasadnij.
    \begin{center}
        Złożoność czasowa procedury \verb+merge_sort+ wynosi $O(nlogn)$, ponieważ każde wywołanie procedury 
        \verb+merge_sort+ dzieli tablicę na dwie części o połowie długości, a następnie wywołuje procedurę \verb+merge+ 
        na tych dwóch częściach. Złożoność czasowa nie zależy od ilości elementów i tego jak są posortowane. 
        Algorym \verb+merge_sort+ składa się z dwóch etapów: divide i merge. \\
        \begin{center}
            Złożoność czasowa etapu divide wynosi $O(n)$, ponieważ wykonujemy $n - 1$ podziałów. \\
            Złożoność czasowa etapu merge wynosi $O(nlogn)$, ponieważ wykonujemy $lb n$ scaleń mając zawsze
            do dyspozycji $n$ elementów. \\                
        \end{center}
        Razem złożoność czasowa algorytmu \verb+merge_sort+ wynosi: $O(n) + O(nlogn) = O(nlogn)$
    \end{center}
    \begin{gather*}
        \text{Dowód metodą rekurencji uniwersalnej:} \\
        T(n) = 2T(n/2) + O(n) \\
        f(n) = n^{log_2 2} = n \\
        \text{Rozważamy drugi przypadek:} \\
        T(n) = O(n \log n)
    \end{gather*}

    \subsection*{Zadanie 4}
    Ile co najwyżej porównań (między elementami tablicy) wykona procedura partition?
    \begin{center}
        Procedura partition wykona co najwyżej $n + 1$ \textbf{porównań}. \\
    \end{center}

    \begin{lstlisting}
        int partition(double t[], int n) 
        {
            int k = -1;
            double x = t[n / 2];
            for (;;) {
                do
                    ++k;
                while (t[k] < x);

                do
                    --n;
                while (t[n] > x);

                if (k < n)
                    std::swap(t[k], t[n]);
                else
                    return k;
            }
        }
    \end{lstlisting}
    
    \pagebreak

    \subsection*{Zadanie 5}
    Jak jest średnia a jaka pesymistyczna złożoność \verb+quick_sort+. Odpowiedź uzasadnij.

    \begin{center}
    Średnia złożoność czasowa algorytmu \verb+quick_sort+ wynosi $O(nlogn)$. \\
    pesymistyczna złożoność czasowa algorytmu \verb+quick_sort+ wynosi $O(n^2)$. \\
    \end{center}

    \begin{lstlisting}
            void quick_sort(double t[], int n)
            {
                if (n > 1) {
                    int k = partition(t, n);  // podziel na dwie czesci
                    quick_sort(t, k);         // posortuj lewa
                    quick_sort(t + k, n - k); // posortuj prawa
                }
            }
    \end{lstlisting}

    \subsection*{Zadanie 6}
    Jaka jest złożoność funkcji buildheap? Przeprowadź dowód - uzasadnij swoją odpowiedź.

    \begin{lstlisting}
        void sift_down(double t[], int n, int i)
        {   /*
            Przesiej element t[i] w dol kopca:
            t[2*i+1] - lewe dziecko t[i]
            t[2*i+2] - prawe dziecko t[i]
            jesli ktores z dzieci jest wieksze od t[i]:
            - zamien t[i] z tym dzieckiem miejscami
            - sprawdz ponownie t[i] w nowym miejscu
            */

            int k = i;
            double x = t[i];
            // x mniejszy od wiekszego syna
            while (((k += k + 2) < n && t[k - 1] < t[k] || --k < n) && x < t[k]) 
            {
                t[i] = t[k];
                i = k;
            }
            t[i] = x;
        }

        void build_max_heap(double t[])
        {
            for (int i = n / 2; i >= 0; i--)
                sift_down(t, i);
        }
    \end{lstlisting}
    
    \pagebreak
    \subsection*{Zadanie 11}
    Czy ciąg \verb+{23, 17, 14, 6, 13, 10, 1, 5, 7, 12}+ jest kopcem?
    \begin{center}
        Ciąg nie jest kopcem, ponieważ węzeł o wartości 7 nie spełnia warunku kopca. \\
        Niespełnionym warunkiem kopca jest to, że dziecko nie może być większe od swojego rodzica. \\
        \vspace{5mm}

        \begin{forest}
            for tree={circle, draw, minimum size=4ex, inner sep=1pt, s sep=5mm, anchor=south, fill=green}
            [23
                [17
                    [6
                        [5]
                        [7, fill=red!50]
                    ]
                    [13 [12]
                        [, no edge, draw=none, fill=none]
                    ]
                ]
                [14
                    [10
                        [, no edge, draw=none, fill=none]
                        [, no edge, draw=none, fill=none]
                    ]
                    [1
                        [, no edge, draw=none, fill=none]
                        [, no edge, draw=none, fill=none]
                    ]
                ]
            ]
        \end{forest}
    \end{center}

\end{document}